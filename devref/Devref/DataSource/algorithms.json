{
    "algorithmsDict": [
                   {
                   "name": "Bubble Sort",
                   "scheme": "",
                   "info":"The algorithm works by comparing each item in the list with the item next to it, and swapping them if required. In other words, the largest element has bubbled to the top of the array. The algorithm repeats this process until it makes a pass all the way through the list without swapping any items."
                   
                   },
                   {
                   "name": "Selection Sort",
                   "scheme": "",
                   "info": "The algorithm works by selecting the smallest unsorted item and then swapping it with the item in the next position to be filled.The selection sort works as follows: you look through the entire array for the smallest element, once you find it you swap it (the smallest element) with the first element of the array. Then you look for the smallest element in the remaining array (an array without the first element) and swap it with the second element. Then you look for the smallest element in the remaining array (an array without first and second elements) and swap it with the third element, and so on."
                   },
                   {
                   "name": "Bucket Sort",
                   "scheme": "",
                   "info": "Bucket sort is a comparison sort algorithm that operates on elements by dividing them into different buckets and then sorting these buckets individually. Each bucket is sorted individually using a separate sorting algorithm or by applying the bucket sort algorithm recursively. Bucket sort is mainly useful when the input is uniformly distributed over a range."
                   },
                   {
                   "name": "Insertion Sort",
                   "scheme": "",
                   "info": "Insertion sort is based on the idea that one element from the input elements is consumed in each iteration to find its correct position i.e, the position to which it belongs in a sorted array. It iterates the input elements by growing the sorted array at each iteration. It compares the current element with the largest value in the sorted array. If the current element is greater, then it leaves the element in its place and moves on to the next element else it finds its correct position in the sorted array and moves it to that position. This is done by shifting all the elements, which are larger than the current element, in the sorted array to one position ahead"
                   },
                   {
                   "name": "Merge Sort",
                   "scheme": "",
                   "info": "Merge sort is a divide-and-conquer algorithm based on the idea of breaking down a list into several sub-lists until each sublist consists of a single element and merging those sublists in a manner that results into a sorted list."
                   },
                   {
                   "name": "Quick Sort",
                   "scheme": "",
                   "info": "Quick sort is based on the divide-and-conquer approach based on the idea of choosing one element as a pivot element and partitioning the array around it such that: Left side of pivot contains all the elements that are less than the pivot element Right side contains all elements greater than the pivot. It reduces the space complexity and removes the use of the auxiliary array that is used in merge sort. Selecting a random pivot in an array results in an improved time complexity in most of the cases."
                   },
                   {
                   "name": "Radix Sort",
                   "scheme": "",
                   "info": "he radix sorting algorithm is an integer sorting algorithm, that sorts by grouping numbers by their individual digits (or by their radix). It uses each radix/digit as a key, and implements counting sort or bucket sort under the hood in order to do the work of sorting."
                   },
                   {
                   "name": "Counting Sort",
                   "scheme": "",
                   "info": "In Counting sort, the frequencies of distinct elements of the array to be sorted is counted and stored in an auxiliary array, by mapping its value as an index of the auxiliary array."
                   },
                   {
                   "name": "Heap Sort",
                   "scheme": "",
                   "info": "Heap sort is a comparison based sorting technique based on Binary Heap data structure. It is similar to selection sort where we first find the maximum element and place the maximum element at the end. We repeat the same process for remaining element."
                   }
                   ]
}
