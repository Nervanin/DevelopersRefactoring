{
    "sections": [
                 {
                 "id": 1,
                 "sectionTitle": "CREATIONAL PATTERNS"
                 },
                 {
                 "id": 2,
                 "sectionTitle": "STRUCTURAL PATTERNS"
                 },
                 {
                 "id": 3,
                 "sectionTitle": "BEHAVIORAL PATTERNS"
                 }
                 ],
    "items": [
              {
              "section": 1,
              "name": "Abstract Factory",
              "scheme": "abstractFactory.jpg",
              "info": "Provide a level of indirection that abstracts the creation of families of related or dependent objects without directly specifying their concrete classes. The \"factory\" object has the responsibility for providing creation services for the entire platform family. Clients never create platform objects directly, they ask the factory to do that for them. \n \nThis mechanism makes exchanging product families easy because the specific class of the factory object appears only once in the application - where it is instantiated. The application can wholesale replace the entire family of products simply by instantiating a different concrete instance of the abstract factory. \n \nBecause the service provided by the factory object is so pervasive, it is routinely implemented as a Singleton."
              },
              {
              "section": 1,
              "name": "Builder",
              "scheme": "builder.jpg",
              "info":
              "Separate the algorithm for interpreting (i.e. reading and parsing) a stored persistence mechanism (e.g. RTF files) from the algorithm for building and representing one of many target products (e.g. ASCII, TeX, text widget). The focus/distinction is on creating complex aggregates. \n \nThe \"director\" invokes \"builder\" services as it interprets the external format. The \"builder\" creates part of the complex object each time it is called and maintains all intermediate state. When the product is finished, the client retrieves the result from the \"builder\". \n \nAffords finer control over the construction process. Unlike creational patterns that construct products in one shot, the Builder pattern constructs the product step by step under the control of the \"director\"."
              },
              {
              "section": 1,
              "name": "Factory method",
              "scheme": "factoryMethod.jpg",
              "info": "Factory Method is to creating objects as Template Method is to implementing an algorithm. A superclass specifies all standard and generic behavior (using pure virtual \"placeholders\" for creation steps), and then delegates the creation details to subclasses that are supplied by the client. \n \nFactory Method makes a design more customizable and only a little more complicated. Other design patterns require new classes, whereas Factory Method only requires a new operation. \n \nPeople often use Factory Method as the standard way to create objects; but it isn't necessary if: the class that's instantiated never changes, or instantiation takes place in an operation that subclasses can easily override (such as an initialization operation). \n \n Factory Method is similar to Abstract Factory but without the emphasis on families. \n \nFactory Methods are routinely specified by an architectural framework, and then implemented by the user of the framework."
              },
              {
              "section": 1,
              "name": "Lazy initialization",
              "scheme": "lazyInitialization.jpg",
              "info": "In computer programming, lazy initialization is the tactic of delaying the creation of an object, the calculation of a value, or some other expensive process until the first time it is needed. It is a kind of lazy evaluation that refers specifically to the instantiation of objects or other resources. \n \nThis is typically accomplished by augmenting an accessor method (or property getter) to check whether a private member, acting as a cache, has already been initialized. If it has, it is returned straight away. If not, a new instance is created, placed into the member variable, and returned to the caller just-in-time for its first use. \n \nIf objects have properties that are rarely used, this can improve startup speed. Mean average program performance may be slightly worse in terms of memory (for the condition variables) and execution cycles (to check them), but the impact of object instantiation is spread in time (\"amortized\") rather than concentrated in the startup phase of a system, and thus median response times can be greatly improved. \n \nIn multithreaded code, access to lazy-initialized objects/state must be synchronized to guard against race conditions."
              },
              {
              "section": 1,
              "name": "Object pool",
              "scheme": "objectPool.jpg",
              "info": "The Object Pool lets others \"check out\" objects from its pool, when those objects are no longer needed by their processes, they are returned to the pool in order to be reused. \n \nHowever, we don't want a process to have to wait for a particular object to be released, so the Object Pool also instantiates new objects as they are required, but must also implement a facility to clean up unused objects periodically."
              },
              {
              "section": 1,
              "name": "Prototype",
              "scheme": "prototype.jpg",
              "info": "Declare an abstract base class that specifies a pure virtual \"clone\" method, and, maintains a dictionary of all \"cloneable\" concrete derived classes. Any class that needs a \"polymorphic constructor\" capability: derives itself from the abstract base class, registers its prototypical instance, and implements the clone() operation. \n \nThe client then, instead of writing code that invokes the \"new\" operator on a hard-wired class name, calls a \"clone\" operation on the abstract base class, supplying a string or enumerated data type that designates the particular concrete derived class desired."
              },
              {
              "section": 1,
              "name": "Singleton",
              "scheme": "singleton.jpg",
              "info": "Make the class of the single instance object responsible for creation, initialization, access, and enforcement. Declare the instance as a private static data member. Provide a public static member function that encapsulates all initialization code, and provides access to the instance. \n \nThe client calls the accessor function (using the class name and scope resolution operator) whenever a reference to the single instance is required. \n \nSingleton should be considered only if all three of the following criteria are satisfied: \n \n-Ownership of the single instance cannot be reasonably assigned \n-Lazy initialization is desirable \n-Global access is not otherwise provided for. \n \nIf ownership of the single instance, when and how initialization occurs, and global access are not issues, Singleton is not sufficiently interesting. \n \nThe Singleton pattern can be extended to support access to an application-specific number of instances. \n \nThe \"static member function accessor\" approach will not support subclassing of the Singleton class. If subclassing is desired, refer to the discussion in the book. \n \nDeleting a Singleton class/instance is a non-trivial design problem. See \"To Kill A Singleton\" by John Vlissides for a discussion."
              },
              {
              "section": 1,
              "name": "Multiton",
              "scheme": "",
              "info": "2"
              },
              {
              "section": 2,
              "name": "Adapter",
              "scheme": "AdapterPattern.jpg",
              "info": "2"
              },
              {
              "section": 2,
              "name": "Bridje",
              "scheme": "Bridge.jpg",
              "info": "2"
              },
              {
              "section": 2,
              "name": "Composite",
              "scheme": "",
              "info": "2.1"
              },
              {
              "section": 2,
              "name": "Decarator",
              "scheme": "",
              "info": "2"
              },
              {
              "section": 2,
              "name": "Facade",
              "scheme": "",
              "info": "2"
              },
              {
              "section": 2,
              "name": "Front Controller",
              "scheme": "",
              "info": "2"
              },
              {
              "section": 2,
              "name": "Flyweight",
              "scheme": "",
              "info": "2"
              },
              {
              "section": 2,
              "name": "Proxy",
              "scheme": "",
              "info": "2"
              },
              {
              "section": 3,
              "name": "Chain of responsibilily",
              "scheme": "",
              "info": "3"
              },
              {
              "section": 3,
              "name": "Cammand",
              "scheme": "",
              "info": "3.1"
              },
              {
              "section": 3,
              "name": "Interpreter",
              "scheme": "",
              "info": "3"
              },
              {
              "section": 3,
              "name": "Iterator",
              "scheme": "",
              "info": "3"
              },
              {
              "section": 3,
              "name": "Mediator",
              "scheme": "",
              "info": "3"
              },
              {
              "section": 3,
              "name": "Memento",
              "scheme": "",
              "info": "3"
              },
              {
              "section": 3,
              "name": "Null Object",
              "scheme": "",
              "info": "3"
              },
              {
              "section": 3,
              "name": "Observer",
              "scheme": "",
              "info": "3"
              },
              {
              "section": 3,
              "name": "State",
              "scheme": "",
              "info": "3"
              },
              {
              "section": 3,
              "name": "Strategy",
              "scheme": "",
              "info": "3"
              },
              {
              "section": 3,
              "name": "Template method",
              "scheme": "",
              "info": "3"
              },
              {
              "section": 3,
              "name": "Visitor",
              "scheme": "",
              "info": "3"
              }
              ]
    
}
