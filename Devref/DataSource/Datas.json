{
    "patterns": {
        "sections": [
            {
                "id": 0,
                "title": "CREATIONAL"
            },
            {
                "id": 1,
                "title": "STRUCTURAL"
            },
            {
                "id": 2,
                "title": "BEHAVIORAL"
            }
        ],
        "items": [
            {
                "id": 0,
                "title": "Factory",
                "section": 0,
                "info": [
                    {
                        "header1": "Factory"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "abstractFactory.jpg"
                    },
                    {
                        "text": "Provide a level of indirection that abstracts the creation of families of related or dependent objects without directly specifying their concrete classes. The \"factory\" object has the responsibility for providing creation services for the entire platform family. Clients never create platform objects directly, they ask the factory to do that for them. \n \nThis mechanism makes exchanging product families easy because the specific class of the factory object appears only once in the application - where it is instantiated. The application can wholesale replace the entire family of products simply by instantiating a different concrete instance of the abstract factory. \n \nBecause the service provided by the factory object is so pervasive, it is routinely implemented as a Singleton."
                    }
                ]
            },
            {
                "id": 1,
                "title": "Builder",
                "section": 0,
                "info": [
                    {
                        "header1": "Builder"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "builder.jpg"
                    },
                    {
                        "text": "Separate the algorithm for interpreting (i.e. reading and parsing) a stored persistence mechanism (e.g. RTF files) from the algorithm for building and representing one of many target products (e.g. ASCII, TeX, text widget). The focus/distinction is on creating complex aggregates. \n \nThe \"director\" invokes \"builder\" services as it interprets the external format. The \"builder\" creates part of the complex object each time it is called and maintains all intermediate state. When the product is finished, the client retrieves the result from the \"builder\". \n \nAffords finer control over the construction process. Unlike creational patterns that construct products in one shot, the Builder pattern constructs the product step by step under the control of the \"director\"."
                    }
                ]
            },
            {
                "id": 2,
                "title": "Factory method",
                "section": 0,
                "info": [
                    {
                        "header1": "Factory method"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "factoryMethod.jpg"
                    },
                    {
                        "text": "Factory Method is to creating objects as Template Method is to implementing an algorithm. A superclass specifies all standard and generic behavior (using pure virtual \"placeholders\" for creation steps), and then delegates the creation details to subclasses that are supplied by the client. \n \nFactory Method makes a design more customizable and only a little more complicated. Other design patterns require new classes, whereas Factory Method only requires a new operation. \n \nPeople often use Factory Method as the standard way to create objects; but it isn't necessary if: the class that's instantiated never changes, or instantiation takes place in an operation that subclasses can easily override (such as an initialization operation). \n \n Factory Method is similar to Abstract Factory but without the emphasis on families. \n \nFactory Methods are routinely specified by an architectural framework, and then implemented by the user of the framework."
                    }
                ]
            },
            {
                "id": 3,
                "title": "Lazy initialization",
                "section": 0,
                "info": [
                    {
                        "header1": "Lazy initialization"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "lazyInitialization.jpg"
                    },
                    {
                        "text": "In computer programming, lazy initialization is the tactic of delaying the creation of an object, the calculation of a value, or some other expensive process until the first time it is needed. It is a kind of lazy evaluation that refers specifically to the instantiation of objects or other resources. \n \nThis is typically accomplished by augmenting an accessor method (or property getter) to check whether a private member, acting as a cache, has already been initialized. If it has, it is returned straight away. If not, a new instance is created, placed into the member variable, and returned to the caller just-in-time for its first use. \n \nIf objects have properties that are rarely used, this can improve startup speed. Mean average program performance may be slightly worse in terms of memory (for the condition variables) and execution cycles (to check them), but the impact of object instantiation is spread in time (\"amortized\") rather than concentrated in the startup phase of a system, and thus median response times can be greatly improved. \n \nIn multithreaded code, access to lazy-initialized objects/state must be synchronized to guard against race conditions."
                    }
                ]
            },
            {
                "id": 4,
                "title": "Object pool",
                "section": 0,
                "info": [
                    {
                        "header1": "Object pool"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "objectPool.jpg"
                    },
                    {
                        "text": "The Object Pool lets others \"check out\" objects from its pool, when those objects are no longer needed by their processes, they are returned to the pool in order to be reused. \n \nHowever, we don't want a process to have to wait for a particular object to be released, so the Object Pool also instantiates new objects as they are required, but must also implement a facility to clean up unused objects periodically."
                    }
                ]
            },
            {
                "id": 5,
                "title": "Prototype",
                "section": 0,
                "info": [
                    {
                        "header1": "Prototype"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "prototype.jpg"
                    },
                    {
                        "text": "Declare an abstract base class that specifies a pure virtual \"clone\" method, and, maintains a dictionary of all \"cloneable\" concrete derived classes. Any class that needs a \"polymorphic constructor\" capability: derives itself from the abstract base class, registers its prototypical instance, and implements the clone() operation. \n \nThe client then, instead of writing code that invokes the \"new\" operator on a hard-wired class name, calls a \"clone\" operation on the abstract base class, supplying a string or enumerated data type that designates the particular concrete derived class desired."
                    }
                ]
            },
            {
                "id": 6,
                "title": "Singleton",
                "section": 0,
                "info": [
                    {
                        "header1": "Singleton"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "singleton.jpg"
                    },
                    {
                        "text": "Make the class of the single instance object responsible for creation, initialization, access, and enforcement. Declare the instance as a private static data member. Provide a public static member function that encapsulates all initialization code, and provides access to the instance. \n \nThe client calls the accessor function (using the class name and scope resolution operator) whenever a reference to the single instance is required. \n \nSingleton should be considered only if all three of the following criteria are satisfied: \n \n-Ownership of the single instance cannot be reasonably assigned \n-Lazy initialization is desirable \n-Global access is not otherwise provided for. \n \nIf ownership of the single instance, when and how initialization occurs, and global access are not issues, Singleton is not sufficiently interesting. \n \nThe Singleton pattern can be extended to support access to an application-specific number of instances. \n \nThe \"static member function accessor\" approach will not support subclassing of the Singleton class. If subclassing is desired, refer to the discussion in the book. \n \nDeleting a Singleton class/instance is a non-trivial design problem. See \"To Kill A Singleton\" by John Vlissides for a discussion."
                    }
                ]
            },
            {
                "id": 7,
                "title": "Multiton",
                "section": 0,
                "info": [
                    {
                        "header1": "Multiton"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "multiton.jpg"
                    },
                    {
                        "text": "Separate the algorithm for interpreting (i.e. reading and parsing) a stored persistence mechanism (e.g. RTF files) from the algorithm for building and representing one of many target products (e.g. ASCII, TeX, text widget). The focus/distinction is on creating complex aggregates. \n \nThe \"director\" invokes \"builder\" services as it interprets the external format. The \"builder\" creates part of the complex object each time it is called and maintains all intermediate state. When the product is finished, the client retrieves the result from the \"builder\". \n \nAffords finer control over the construction process. Unlike creational patterns that construct products in one shot, the Builder pattern constructs the product step by step under the control of the \"director\"."
                    }
                ]
            },
            {
                "id": 0,
                "title": "Adapter",
                "section": 1,
                "info": [
                    {
                        "header1": "Adapter"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "adapter.jpg"
                    },
                    {
                        "text": "Adapter pattern works as a bridge between two incompatible interfaces. This type of design pattern comes under structural pattern as this pattern combines the capability of two independent interfaces. \n \nThis pattern involves a single class which is responsible to join functionalities of independent or incompatible interfaces. A real life example could be a case of card reader which acts as an adapter between memory card and a laptop. You plugin the memory card into card reader and card reader into the laptop so that memory card can be read via laptop. \n \nWe are demonstrating use of Adapter pattern via following example in which an audio player device can play mp3 files only and wants to use an advanced audio player capable of playing vlc and mp4 files."
                    }
                ]
            },
            {
                "id": 1,
                "title": "Bridje",
                "section": 1,
                "info": [
                    {
                        "header1": "Bridje"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "Bridge.jpg"
                    },
                    {
                        "text": "Bridge is used when we need to decouple an abstraction from its implementation so that the two can vary independently. This type of design pattern comes under structural pattern as this pattern decouples implementation class and abstract class by providing a bridge structure between them. \n \nThis pattern involves an interface which acts as a bridge which makes the functionality of concrete classes independent from interface implementer classes. Both types of classes can be altered structurally without affecting each other.\n \nWe are demonstrating use of Bridge pattern via following example in which a circle can be drawn in different colors using same abstract class method but different bridge implementer classes."
                    }
                ]
            },
            {
                "id": 2,
                "title": "Composite",
                "section": 1,
                "info": [
                    {
                        "header1": "Composite"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "composite.jpg"
                    },
                    {
                        "text": "Composite pattern is used where we need to treat a group of objects in similar way as a single object. Composite pattern composes objects in term of a tree structure to represent part as well as whole hierarchy. This type of design pattern comes under structural pattern as this pattern creates a tree structure of group of objects. \n \nThis pattern creates a class that contains group of its own objects. This class provides ways to modify its group of same objects. \n \nWe are demonstrating use of composite pattern via following example in which we will show employees hierarchy of an organization."
                    }
                ]
            },
            {
                "id": 3,
                "title": "Decarator",
                "section": 1,
                "info": [
                    {
                        "header1": "Decarator"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "decorator.jpg"
                    },
                    {
                        "text": "Decorator pattern allows a user to add new functionality to an existing object without altering its structure. This type of design pattern comes under structural pattern as this pattern acts as a wrapper to existing class. \n \nThis pattern creates a decorator class which wraps the original class and provides additional functionality keeping class methods signature intact. \n \nWe are demonstrating the use of decorator pattern via following example in which we will decorate a shape with some color without alter shape class."
                    }
                ]
            },
            {
                "id": 4,
                "title": "Facade",
                "section": 1,
                "info": [
                    {
                        "header1": "Facade"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "facade.jpg"
                    },
                    {
                        "text": "Facade pattern hides the complexities of the system and provides an interface to the client using which the client can access the system. This type of design pattern comes under structural pattern as this pattern adds an interface to existing system to hide its complexities. \n \nThis pattern involves a single class which provides simplified methods required by client and delegates calls to methods of existing system classes."
                    }
                ]
            },
            {
                "id": 5,
                "title": "Front Controller",
                "section": 1,
                "info": [
                    {
                        "header1": "Front Controller"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "frontController.jpg"
                    },
                    {
                        "text": "The front controller design pattern is used to provide a centralized request handling mechanism so that all requests will be handled by a single handler. This handler can do the authentication/ authorization/ logging or tracking of request and then pass the requests to corresponding handlers. Following are the entities of this type of design pattern. \n \nFront Controller - Single handler for all kinds of requests coming to the application (either web based/ desktop based). \n \nDispatcher - Front Controller may use a dispatcher object which can dispatch the request to corresponding specific handler. \n \nView - Views are the object for which the requests are made."
                    }
                ]
            },
            {
                "id": 6,
                "title": "Flyweight",
                "section": 1,
                "info": [
                    {
                        "header1": "Flyweight"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "flyWeight.jpg"
                    },
                    {
                        "text": "Flyweight pattern is primarily used to reduce the number of objects created and to decrease memory footprint and increase performance. This type of design pattern comes under structural pattern as this pattern provides ways to decrease object count thus improving the object structure of application. \n \nFlyweight pattern tries to reuse already existing similar kind objects by storing them and creates new object when no matching object is found. We will demonstrate this pattern by drawing 20 circles of different locations but we will create only 5 objects. Only 5 colors are available so color property is used to check already existing Circle objects."
                    }
                ]
            },
            {
                "id": 7,
                "title": "Proxy",
                "section": 1,
                "info": [
                    {
                        "header1": "Proxy"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "proxyPattern.jpg"
                    },
                    {
                        "text": "In proxy pattern, a class represents functionality of another class. This type of design pattern comes under structural pattern. \n \nIn proxy pattern, we create object having original object to interface its functionality to outer world."
                    }
                ]
            },
            {
                "id": 0,
                "title": "Chain of responsibilily",
                "section": 2,
                "info": [
                    {
                        "header1": "Chain of responsibilily"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "abstractFactory.jpg"
                    },
                    {
                        "text": "Pattern3"
                    }
                ]
            },
            {
                "id": 1,
                "title": "Cammand",
                "section": 2,
                "info": [
                    {
                        "header1": "Cammand"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "abstractFactory.jpg"
                    },
                    {
                        "text": "Pattern3"
                    }
                ]
            },
            {
                "id": 2,
                "title": "Interpreter",
                "section": 2,
                "info": [
                    {
                        "header1": "Interpreter"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "abstractFactory.jpg"
                    },
                    {
                        "text": "Pattern3"
                    }
                ]
            },
            {
                "id": 3,
                "title": "Iterator",
                "section": 2,
                "info": [
                    {
                        "header1": "Iterator"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "abstractFactory.jpg"
                    },
                    {
                        "text": "Pattern3"
                    }
                ]
            },
            {
                "id": 4,
                "title": "Mediator",
                "section": 2,
                "info": [
                    {
                        "header1": "Mediator"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "abstractFactory.jpg"
                    },
                    {
                        "text": "Pattern3"
                    }
                ]
            },
            {
                "id": 5,
                "title": "Memento",
                "section": 2,
                "info": [
                    {
                        "header1": "Memento"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "abstractFactory.jpg"
                    },
                    {
                        "text": "Pattern3"
                    }
                ]
            },
            {
                "id": 6,
                "title": "Null Object",
                "section": 2,
                "info": [
                    {
                        "header1": "Null Object"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "abstractFactory.jpg"
                    },
                    {
                        "text": "Pattern3"
                    }
                ]
            },
            {
                "id": 7,
                "title": "Observer",
                "section": 2,
                "info": [
                    {
                        "header1": "Observer"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "abstractFactory.jpg"
                    },
                    {
                        "text": "Pattern3"
                    }
                ]
            },
            
            {
                "id": 8,
                "title": "State",
                "section": 2,
                "info": [
                    {
                        "header1": "State"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "abstractFactory.jpg"
                    },
                    {
                        "text": "Pattern3"
                    }
                ]
            },
            {
                "id": 9,
                "title": "Strategy",
                "section": 2,
                "info": [
                    {
                        "header1": "Strategy"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "abstractFactory.jpg"
                    },
                    {
                        "text": "Pattern3"
                    }
                ]
            },
            {
                "id": 10,
                "title": "Template method",
                "section": 2,
                "info": [
                    {
                        "header1": "Template method"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "abstractFactory.jpg"
                    },
                    {
                        "text": "Pattern3"
                    }
                ]
            },
            {
                "id": 11,
                "title": "Visitor",
                "section": 2,
                "info": [
                    {
                        "header1": "Visitor"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "abstractFactory.jpg"
                    },
                    {
                        "text": "Pattern3"
                    }
                ]
            },
        ]
    },
    "algorithms": {
        "items": [
            {
                "id": 0,
                "title": "Bubble Sort",
                "section": null,
                "info": [
                    {
                        "header1": "Bubble Sort"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "abstractFactory.jpg"
                    },
                    {
                        "text": "The algorithm works by comparing each item in the list with the item next to it, and swapping them if required. In other words, the largest element has bubbled to the top of the array. The algorithm repeats this process until it makes a pass all the way through the list without swapping any items."
                    }
                ]
            },
            {
                "id": 1,
                "title": "Selection Sort",
                "section": null,
                "info": [
                    {
                        "header1": "Selection Sort"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "abstractFactory.jpg"
                    },
                    {
                        "text": "The algorithm works by selecting the smallest unsorted item and then swapping it with the item in the next position to be filled.The selection sort works as follows: you look through the entire array for the smallest element, once you find it you swap it (the smallest element) with the first element of the array. Then you look for the smallest element in the remaining array (an array without the first element) and swap it with the second element. Then you look for the smallest element in the remaining array (an array without first and second elements) and swap it with the third element, and so on."
                    }
                ]
            },
            {
                "id": 2,
                "title": "Bucket Sort",
                "section": null,
                "info": [
                    {
                        "header1": "Bucket Sort"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "abstractFactory.jpg"
                    },
                    {
                        "text": "Bucket sort is a comparison sort algorithm that operates on elements by dividing them into different buckets and then sorting these buckets individually. Each bucket is sorted individually using a separate sorting algorithm or by applying the bucket sort algorithm recursively. Bucket sort is mainly useful when the input is uniformly distributed over a range."
                    }
                ]
            },
            {
                "id": 2,
                "title": "Insertion Sort",
                "section": null,
                "info": [
                    {
                        "header1": "Insertion Sort"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "abstractFactory.jpg"
                    },
                    {
                        "text": "Insertion sort is based on the idea that one element from the input elements is consumed in each iteration to find its correct position i.e, the position to which it belongs in a sorted array. It iterates the input elements by growing the sorted array at each iteration. It compares the current element with the largest value in the sorted array. If the current element is greater, then it leaves the element in its place and moves on to the next element else it finds its correct position in the sorted array and moves it to that position. This is done by shifting all the elements, which are larger than the current element, in the sorted array to one position ahead"
                    }
                ]
            },
            {
                "id": 3,
                "title": "Merge Sort",
                "section": null,
                "info": [
                    {
                        "header1": "Merge Sort"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "abstractFactory.jpg"
                    },
                    {
                        "text": "Merge sort is a divide-and-conquer algorithm based on the idea of breaking down a list into several sub-lists until each sublist consists of a single element and merging those sublists in a manner that results into a sorted list."
                    }
                ]
            },
            {
                "id": 4,
                "title": "Quick Sort",
                "section": null,
                "info": [
                    {
                        "header1": "Quick Sort"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "abstractFactory.jpg"
                    },
                    {
                        "text": "Quick sort is based on the divide-and-conquer approach based on the idea of choosing one element as a pivot element and partitioning the array around it such that: Left side of pivot contains all the elements that are less than the pivot element Right side contains all elements greater than the pivot. It reduces the space complexity and removes the use of the auxiliary array that is used in merge sort. Selecting a random pivot in an array results in an improved time complexity in most of the cases."
                    }
                ]
            },
            {
                "id": 5,
                "title": "Radix Sort",
                "section": null,
                "info": [
                    {
                        "header1": "Radix Sort"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "abstractFactory.jpg"
                    },
                    {
                        "text": "The radix sorting algorithm is an integer sorting algorithm, that sorts by grouping numbers by their individual digits (or by their radix). It uses each radix/digit as a key, and implements counting sort or bucket sort under the hood in order to do the work of sorting."
                    }
                ]
            },
            {
                "id": 6,
                "title": "Counting Sort",
                "section": null,
                "info": [
                    {
                        "header1": "Counting Sort"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "abstractFactory.jpg"
                    },
                    {
                        "text": "In Counting sort, the frequencies of distinct elements of the array to be sorted is counted and stored in an auxiliary array, by mapping its value as an index of the auxiliary array."
                    }
                ]
            },
            {
                "id": 7,
                "title": "Heap Sort",
                "section": null,
                "info": [
                    {
                        "header1": "Heap Sort"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "abstractFactory.jpg"
                    },
                    {
                        "text": "Heap sort is a comparison based sorting technique based on Binary Heap data structure. It is similar to selection sort where we first find the maximum element and place the maximum element at the end. We repeat the same process for remaining element."
                    }
                ]
            },
            
        ]
    },
    "data_structures": {
        "items": [
            {
                "id": 0,
                "title": "inked Lists",
                "section": null,
                "info": [
                    {
                        "header1": "inked Lists"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "abstractFactory.jpg"
                    },
                    {
                        "text": "A linked list is one of the most basic data structures. It is often compared to an array since many other data structures can be implemented with either an array or a linked list. They each have advantages and disadvantages. A linked list consists of a group of nodes which together represent a sequence. Each node contains two things: the actual data being stored (which can be basically any type of data) and a pointer (or link) to the next node in the sequence. There are also doubly linked lists where each node has a pointer to both the next item and the previous item in the list. The most basic operations in a linked list are adding an item to the list, deleting an item from the list, and searching the list for an item.A linked list is one of the most basic data structures. It is often compared to an array since many other data structures can be implemented with either an array or a linked list. They each have advantages and disadvantages. A linked list consists of a group of nodes which together represent a sequence. Each node contains two things: the actual data being stored (which can be basically any type of data) and a pointer (or link) to the next node in the sequence. There are also doubly linked lists where each node has a pointer to both the next item and the previous item in the list. The most basic operations in a linked list are adding an item to the list, deleting an item from the list, and searching the list for an item.A linked list is one of the most basic data structures. It is often compared to an array since many other data structures can be implemented with either an array or a linked list. They each have advantages and disadvantages. A linked list consists of a group of nodes which together represent a sequence. Each node contains two things: the actual data being stored (which can be basically any type of data) and a pointer (or link) to the next node in the sequence. There are also doubly linked lists where each node has a pointer to both the next item and the previous item in the list. The most basic operations in a linked list are adding an item to the list, deleting an item from the list, and searching the list for an item."
                    }
                ]
            },
            {
                "id": 1,
                "title": "Stacks",
                "section": null,
                "info": [
                    {
                        "header1": "Stacks"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "abstractFactory.jpg"
                    },
                    {
                        "text": "A stack is a basic data structure where you can only insert or delete items at the top of the stack. It is kind of similar to a stack of books. If you want to look at a book in the middle of the stack you must take all of the books above it off first. The stack is considered LIFO (Last In First Out) meaning the last item you put in the stack is the first item that comes out of the stack. There are three main operations that can be performed on stacks: inserting an item into a stack (called ‘push’), deleting an item from the stack (called ‘pop’), and displaying the contents of the stack (sometimes called ‘pip’)."
                    }
                ]
            },
            {
                "id": 2,
                "title": "Queues",
                "section": null,
                "info": [
                    {
                        "header1": "Queues"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "abstractFactory.jpg"
                    },
                    {
                        "text": "You can think of a queue as a line of people at a grocery store. The first one in the line is the first one to be served. Just like a queue. A queue is considered FIFO (First In First Out) to demonstrate the way it accesses data. This means that once a new element is added, all elements that were added before have to be removed before the new element can be removed. A queue has just two main operations: enqueue and dequeue. Enqueue means to insert an item into the back of the queue and dequeue means removing the front item."
                    }
                ]
            },
            {
                "id": 3,
                "title": "Graph",
                "section": null,
                "info": [
                    {
                        "header1": "Graph"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "abstractFactory.jpg"
                    },
                    {
                        "text": "Graphs are collections of nodes (also called vertices) and the connections (called edges) between them. Graphs are also known as networks. One example of graphs is a social network. The nodes are people and the edges are friendship. An adjacency list can be represented as a list where the left side is the node and the right side lists all the other nodes it’s connected to. An adjacency matrix is a grid of numbers, where each row or column represents a different node in the graph. At the intersection of a row and a column is a number that indicates the relationship. Zeros mean there is no edge or relationship. Ones mean there is a relationship. Numbers higher than one can be used to show different weights. Traversal algorithms are algorithms to traverse or visit nodes in a graph. The main types of traversal algorithms are breadth-first search and depth-first search. One of the uses is to determine how close nodes are to a root node. See how to implement breadth-first search in JavaScript in the video below."
                    }
                ]
            },
            {
                "id": 4,
                "title": "Sets",
                "section": null,
                "info": [
                    {
                        "header1": "Sets"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "abstractFactory.jpg"
                    },
                    {
                        "text": "The set data structure stores values without any particular order and with no repeated values. Besides being able to add and remove elements to a set, there are a few other important set functions that work with two sets at once. Union — This combines all the items from two different sets and returns this as a new set (with no duplicates). Intersection — Given two sets, this function returns another set that has all items that are part of both sets. Difference — This returns a list of items that are in one set but NOT in a different set.Subset — This returns a boolean value that shows if all the elements in one set are included in a different set."
                    }
                ]
            },
            {
                "id": 5,
                "title": "Maps",
                "section": null,
                "info": [
                    {
                        "header1": "Maps"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "abstractFactory.jpg"
                    },
                    {
                        "text": "A map is a data structure that stores data in key / value pairs where every key is unique. A map is sometimes called an associative array or dictionary. It is often used for fast look-ups of data. Maps allow the following things: the addition of a pair to the collection. The removal of a pair from the collection. The modification of an existing pair. The lookup of a value associated with a particular key."
                    }
                ]
            },
            {
                "id": 6,
                "title": "Hash Tables",
                "section": null,
                "info": [
                    {
                        "header1": "Hash Tables"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "abstractFactory.jpg"
                    },
                    {
                        "text": "A hash table is a map data structure that contains key / value pairs. It uses a hash function to compute an index into an array of buckets or slots, from which the desired value can be found. The hash function usually takes a string as input and it outputs an numerical value. The hash function should always give the same output number for the same input. When two inputs hash to the same numerical output, this is called a collision. The goal is to have few collisions. So when you input a key / value pair into a hash table, the key is run through the hash function and turned into a number. This numerical value is then used as the actual key that the value is stored by. When you try to access the same key again, the hashing function will process the key and return the same numerical result. The number will then be used to look up the associated value. This provides very efficient O(1) lookup time on average."
                    }
                ]
            },
            {
                "id": 7,
                "title": "Binary Search Tree",
                "section": null,
                "info": [
                    {
                        "header1": "Binary Search Tree"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "abstractFactory.jpg"
                    },
                    {
                        "text": "A stack is a basic data structure where you can only insert or delete items at the top of the stack. It is kind of similar to a stack of books. If you want to look at a book in the middle of the stack you must take all of the books above it off first. The stack is considered LIFO (Last In First Out) meaning the last item you put in the stack is the first item that comes out of the stack. There are three main operations that can be performed on stacks: inserting an item into a stack (called ‘push’), deleting an item from the stack (called ‘pop’), and displaying the contents of the stack (sometimes called ‘pip’)."
                    }
                ]
            },
            {
                "id": 8,
                "title": "Trie",
                "section": null,
                "info": [
                    {
                        "header1": "Trie"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "abstractFactory.jpg"
                    },
                    {
                        "text": "The trie (pronounced ‘try’), or prefix tree, is a kind of search tree. A trie stores data in steps where each step is a node in the trie. Tries are often used to store words for quick lookup, such as a word auto-complete feature. Each node in a language trie contains one letter of a word. You follow the branches of a trie to spell a word, one letter at a time. The steps begin to branch off when the order of the letters diverge from the other words in the trie, or when a word ends. Each node contains a letter (data) and a boolean that indicates whether the node is the last node in a word. Look at the image and you can form words. Always start at the root node at the top and work down. The trie shown here contains the word ball, bat, doll, do, dork, dorm, send, sense."
                    }
                ]
            },
            {
                "id": 9,
                "title": "Binary Heap",
                "section": null,
                "info": [
                    {
                        "header1": "Binary Heap"
                    },
                    {
                        "header2": "h2"
                    },
                    {
                        "image": "abstractFactory.jpg"
                    },
                    {
                        "text": "A binary heap is another type of tree data structure. Every node has at most two children. Also, it is a complete tree. This means that all levels are completely filled until the last level and the last level is filled from left to right. A binary heap can be either a min heap or a max heap. In a max heap, the keys of parent nodes are always greater than or equal to those of the children. In a min heap, the keys of parent nodes are less than or equal to those of the children. The order between levels is important but the order of nodes on the same level is not important. In the image, you can see that the third level of the min heap has values 10, 6, and 12. Those numbers are not in order."
                    }
                ]
            },
        ]
    }
}
